"use strict";(self.webpackChunkkaito_website=self.webpackChunkkaito_website||[]).push([[745],{378:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"model-as-oci-artifacts","title":"Model As OCI Artifacts","description":"Efficiently distribute Large Language Models using Open Container Initiative (OCI) Artifacts","source":"@site/versioned_docs/version-v0.6.x/model-as-oci-artifacts.md","sourceDirName":".","slug":"/model-as-oci-artifacts","permalink":"/kaito/docs/model-as-oci-artifacts","draft":false,"unlisted":false,"editUrl":"https://github.com/kaito-project/kaito/tree/main/website/versioned_docs/version-v0.6.x/model-as-oci-artifacts.md","tags":[],"version":"v0.6.x","frontMatter":{"title":"Model As OCI Artifacts","description":"Efficiently distribute Large Language Models using Open Container Initiative (OCI) Artifacts"},"sidebar":"sidebar","previous":{"title":"Tool Calling","permalink":"/kaito/docs/tool-calling"},"next":{"title":"Headlamp KAITO","permalink":"/kaito/docs/headlamp-kaito"}}');var s=n(4848),r=n(8453);const a={title:"Model As OCI Artifacts",description:"Efficiently distribute Large Language Models using Open Container Initiative (OCI) Artifacts"},o="Model As OCI Artifacts",l={},d=[{value:"Overview",id:"overview",level:2},{value:"Design Rationale",id:"design-rationale",level:2},{value:"Build Efficiency",id:"build-efficiency",level:3},{value:"Deployment Performance",id:"deployment-performance",level:3},{value:"Understanding Container Performance",id:"understanding-container-performance",level:4},{value:"How KAITO Uses OCI Artifacts",id:"how-kaito-uses-oci-artifacts",level:2},{value:"1. Efficient Build Process",id:"1-efficient-build-process",level:3},{value:"2. Optimized Compression",id:"2-optimized-compression",level:3},{value:"3. Split Architecture Design",id:"3-split-architecture-design",level:3},{value:"When to Use OCI Artifacts",id:"when-to-use-oci-artifacts",level:2},{value:"Recommended Use Cases",id:"recommended-use-cases",level:3},{value:"Performance Considerations",id:"performance-considerations",level:3},{value:"Architecture",id:"architecture",level:2},{value:"Model Weights Download Process",id:"model-weights-download-process",level:3},{value:"OCI Artifacts vs OCI Images",id:"oci-artifacts-vs-oci-images",level:3},{value:"Alternative Approaches for Large Models",id:"alternative-approaches-for-large-models",level:3},{value:"Compatibility",id:"compatibility",level:2},{value:"Container Runtimes",id:"container-runtimes",level:3},{value:"OCI Registries",id:"oci-registries",level:3},{value:"Benefits",id:"benefits",level:2},{value:"Performance Improvements",id:"performance-improvements",level:3},{value:"Operational Benefits",id:"operational-benefits",level:3},{value:"Performance Results",id:"performance-results",level:2},{value:"Getting Started",id:"getting-started",level:2},{value:"Automatic Usage",id:"automatic-usage",level:3},{value:"Verifying OCI Artifacts Usage",id:"verifying-oci-artifacts-usage",level:3},{value:"Troubleshooting",id:"troubleshooting",level:3}];function c(e){const i={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",img:"img",li:"li",mermaid:"mermaid",ol:"ol",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(i.header,{children:(0,s.jsx)(i.h1,{id:"model-as-oci-artifacts",children:"Model As OCI Artifacts"})}),"\n",(0,s.jsx)(i.p,{children:"KAITO efficiently distributes Large Language Models (LLMs) by leveraging Open Container Initiative (OCI) Artifacts to package and deploy model weights separately from the inference runtime. This architecture provides superior performance, scalability, and maintainability for large language model deployments."}),"\n",(0,s.jsx)(i.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(i.p,{children:"KAITO uses a split architecture approach for model distribution:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Base Images"}),": Contain the inference runtime and dependencies"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"OCI Artifacts"}),": Contain the model weights and configuration files stored separately in OCI registries"]}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:"This design choice enables KAITO to optimize both build and deployment performance while maintaining compatibility with standard container infrastructure. The model weights are downloaded as OCI artifacts during pod initialization, providing faster deployment times and more efficient resource utilization compared to traditional monolithic container images."}),"\n",(0,s.jsx)(i.h2,{id:"design-rationale",children:"Design Rationale"}),"\n",(0,s.jsx)(i.p,{children:"KAITO chose the OCI Artifacts approach to address fundamental challenges in large language model distribution and deployment:"}),"\n",(0,s.jsx)(i.h3,{id:"build-efficiency",children:"Build Efficiency"}),"\n",(0,s.jsx)(i.p,{children:"By separating model weights from base images, KAITO eliminates redundant rebuilds:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Reduced Build Time"}),": Model images only need to be built once and can be reused across base image updates"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Efficient Build Context"}),": Large model files are not included in Docker build context, avoiding unnecessary transfers"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Resource Optimization"}),": Build processes for large models like Falcon-40B are reduced from nearly 2 hours to minutes"]}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"deployment-performance",children:"Deployment Performance"}),"\n",(0,s.jsx)(i.p,{children:"KAITO's OCI Artifacts approach optimizes the deployment pipeline:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Concurrent Downloads"}),": Model weights can be downloaded in parallel, improving bandwidth utilization"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Advanced Compression"}),": Zstd compression provides better decompression performance than traditional gzip"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Optimized Unpacking"}),": Separate artifact handling reduces serialization bottlenecks during pod startup"]}),"\n"]}),"\n",(0,s.jsx)(i.h4,{id:"understanding-container-performance",children:"Understanding Container Performance"}),"\n",(0,s.jsx)(i.p,{children:"KAITO's design optimizes all phases of the container pull process:"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Downloading"})," layer data from the registry"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Decompressing"})," the layer if necessary"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Checking"})," sha256 digest"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Unpacking"})," the layer, applying changes to the snapshot"]}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:"KAITO addresses these performance characteristics by optimizing not just the download phase (30% of total time) but also the decompression, validation, and unpacking phases through its OCI Artifacts approach."}),"\n",(0,s.jsx)(i.h2,{id:"how-kaito-uses-oci-artifacts",children:"How KAITO Uses OCI Artifacts"}),"\n",(0,s.jsx)(i.h3,{id:"1-efficient-build-process",children:"1. Efficient Build Process"}),"\n",(0,s.jsxs)(i.p,{children:["KAITO uses ",(0,s.jsx)(i.a,{href:"https://github.com/oras-project/oras",children:"ORAS"})," to package model weights and configuration files directly into OCI artifacts without requiring large build contexts. This approach achieves the same distribution goals as traditional Docker builds but with significantly improved efficiency."]}),"\n",(0,s.jsx)(i.h3,{id:"2-optimized-compression",children:"2. Optimized Compression"}),"\n",(0,s.jsx)(i.p,{children:"KAITO employs zstd compression instead of gzip, providing superior decompression performance specifically optimized for large model weight files."}),"\n",(0,s.jsx)(i.h3,{id:"3-split-architecture-design",children:"3. Split Architecture Design"}),"\n",(0,s.jsx)(i.p,{children:"KAITO implements a two-component architecture:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Base Image"}),": Contains the inference runtime and dependencies"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"OCI Artifacts"}),": Contains the model weights and configuration files"]}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:"This architectural separation enables model images to be built once and reused across multiple base image updates, significantly reducing maintenance overhead."}),"\n",(0,s.jsx)(i.h2,{id:"when-to-use-oci-artifacts",children:"When to Use OCI Artifacts"}),"\n",(0,s.jsx)(i.p,{children:"KAITO automatically uses OCI Artifacts for supported models, providing benefits in several scenarios:"}),"\n",(0,s.jsx)(i.h3,{id:"recommended-use-cases",children:"Recommended Use Cases"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Large Language Models"}),": Models with weights exceeding 1GB benefit significantly from the optimized distribution"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Frequent Updates"}),": Environments with regular base image updates for security patches or feature additions"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Multi-Model Deployments"}),": When deploying multiple model variants that share similar runtime requirements"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Resource-Constrained Environments"}),": Clusters where build time and bandwidth optimization are critical"]}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,s.jsx)(i.p,{children:"The OCI Artifacts approach provides the most benefit when:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Model weights are large relative to the runtime container"}),"\n",(0,s.jsx)(i.li,{children:"Network bandwidth is limited or expensive"}),"\n",(0,s.jsx)(i.li,{children:"Build infrastructure resources are constrained"}),"\n",(0,s.jsx)(i.li,{children:"Deployment frequency is high"}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"architecture",children:"Architecture"}),"\n",(0,s.jsx)(i.h3,{id:"model-weights-download-process",children:"Model Weights Download Process"}),"\n",(0,s.jsxs)(i.p,{children:["The system uses an ",(0,s.jsx)(i.a,{href:"https://kubernetes.io/docs/concepts/workloads/pods/init-containers/",children:"initContainer"})," to download model weights as OCI artifacts using ORAS:"]}),"\n",(0,s.jsx)(i.mermaid,{value:"sequenceDiagram\n    participant CR as Container Runtime\n    participant IC as InitContainer\n    participant PV as Persistent Volume\n    participant IS as Inference Server\n\n    CR->>CR: Pull Base Image\n    CR->>IC: Start InitContainer\n    IC->>IC: Pull Model Weights as OCI Artifacts using ORAS\n    IC->>PV: Store Model Weights\n    IC->>CR: Complete\n    CR->>IS: Start Main Inference Container\n    IS->>PV: Load Model Weights\n    IS->>IS: Inference Server Ready"}),"\n",(0,s.jsx)(i.h3,{id:"oci-artifacts-vs-oci-images",children:"OCI Artifacts vs OCI Images"}),"\n",(0,s.jsxs)(i.p,{children:["The Open Container Initiative (OCI) defines specifications and standards for container technologies, including the OCI Distribution Specification. OCI Image Manifests have a required field ",(0,s.jsx)(i.code,{children:"config.mediaType"})," that differentiates between various types of artifacts."]}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"OCI Image"}),": A subset of OCI artifacts, accepting only specific mediatypes"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"OCI Artifacts"}),": More general format that can contain various types of content including model weights"]}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:"ORAS (OCI Registry As Storage) is the tool used for managing OCI artifacts, including pushing, pulling, and handling metadata in OCI registries."}),"\n",(0,s.jsx)(i.h3,{id:"alternative-approaches-for-large-models",children:"Alternative Approaches for Large Models"}),"\n",(0,s.jsx)(i.p,{children:"For extremely large models that may not be practical to package as OCI artifacts due to size constraints, KAITO also supports:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Direct Download from Hugging Face"}),": Models can be downloaded directly from Hugging Face Hub during pod initialization for models that exceed registry limitations"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"External Model Caching"}),": Integration with external model caching solutions for improved performance with very large models"]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"compatibility",children:"Compatibility"}),"\n",(0,s.jsx)(i.h3,{id:"container-runtimes",children:"Container Runtimes"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"CRI-O"}),": Supports general OCI artifacts"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Containerd"}),": Limited support for OCI artifacts (see ",(0,s.jsx)(i.a,{href:"https://github.com/containerd/containerd/issues/11381#issuecomment-2917050414",children:"containerd issue"}),")"]}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"oci-registries",children:"OCI Registries"}),"\n",(0,s.jsxs)(i.p,{children:["Most OCI registries support OCI artifacts. For a complete list of compatible registries, see the ",(0,s.jsx)(i.a,{href:"https://oras.land/docs/compatible_oci_registries#registries-supporting-oci-artifacts",children:"ORAS compatibility documentation"}),"."]}),"\n",(0,s.jsx)(i.h2,{id:"benefits",children:"Benefits"}),"\n",(0,s.jsx)(i.h3,{id:"performance-improvements",children:"Performance Improvements"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Reduced Build Time"}),": Model images only need to be built once"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Faster Pulls"}),": Improved download concurrency and compression"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Better Resource Usage"}),": Optimized bandwidth utilization"]}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"operational-benefits",children:"Operational Benefits"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Simplified Maintenance"}),": Base image updates don't require rebuilding all model images"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Storage Efficiency"}),": Better compression ratios with zstd"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Scalability"}),": More efficient handling of large model files"]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"performance-results",children:"Performance Results"}),"\n",(0,s.jsx)(i.p,{children:"Testing on Standard_NC24s_v3 with phi4 model shows significant improvements:"}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.img,{alt:"Model as OCI Artifacts Evaluation",src:n(630).A+"",width:"819",height:"489"})}),"\n",(0,s.jsx)(i.p,{children:"The evaluation compared different configurations:"}),"\n",(0,s.jsxs)(i.table,{children:[(0,s.jsx)(i.thead,{children:(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.th,{children:"Configuration"}),(0,s.jsx)(i.th,{children:"Description"}),(0,s.jsx)(i.th,{children:"Benefits"})]})}),(0,s.jsxs)(i.tbody,{children:[(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Baseline (single-layer-tar-gz)"}),(0,s.jsx)(i.td,{children:"Current approach with all files in one layer"}),(0,s.jsx)(i.td,{children:"Simple, self-contained"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"OCI Artifacts"}),(0,s.jsx)(i.td,{children:"Base image + separate model artifacts"}),(0,s.jsx)(i.td,{children:"Reduced build time, better performance"})]})]})]}),"\n",(0,s.jsx)(i.h2,{id:"getting-started",children:"Getting Started"}),"\n",(0,s.jsx)(i.h3,{id:"automatic-usage",children:"Automatic Usage"}),"\n",(0,s.jsx)(i.p,{children:"KAITO automatically uses OCI Artifacts for supported models when the feature is available. No additional configuration is required - simply deploy your model using standard KAITO workflows and the system will optimize the distribution automatically."}),"\n",(0,s.jsx)(i.h3,{id:"verifying-oci-artifacts-usage",children:"Verifying OCI Artifacts Usage"}),"\n",(0,s.jsx)(i.p,{children:"To confirm that your model is using OCI Artifacts:"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsx)(i.li,{children:"Check the pod specification for initContainers that download model artifacts"}),"\n",(0,s.jsx)(i.li,{children:"Monitor pod startup times for improved performance compared to traditional container pulls"}),"\n",(0,s.jsx)(i.li,{children:"Review registry storage to see separate base images and model artifact entries"}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,s.jsx)(i.p,{children:"If you encounter issues with OCI Artifacts:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Ensure your container runtime supports OCI Artifacts (see Compatibility section)"}),"\n",(0,s.jsx)(i.li,{children:"Verify registry compatibility with OCI Artifacts specification"}),"\n",(0,s.jsx)(i.li,{children:"Check initContainer logs for artifact download status"}),"\n",(0,s.jsxs)(i.li,{children:["Refer to the ",(0,s.jsx)(i.a,{href:"https://github.com/kaito-project/kaito/blob/main/docs/proposals/20250609-model-as-oci-artifacts.md",children:"technical specification"})," for advanced configuration options"]}),"\n"]})]})}function h(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,s.jsx)(i,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},630:(e,i,n)=>{n.d(i,{A:()=>t});const t=n.p+"assets/images/model-as-oci-artifacts-evaluation-0e455974e0dee66f3659aefe5c50cded.png"},8453:(e,i,n)=>{n.d(i,{R:()=>a,x:()=>o});var t=n(6540);const s={},r=t.createContext(s);function a(e){const i=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function o(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(r.Provider,{value:i},e.children)}}}]);