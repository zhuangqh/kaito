"use strict";(self.webpackChunkkaito_website=self.webpackChunkkaito_website||[]).push([[479],{3614:(e,n,r)=>{r.d(n,{A:()=>s});const s=r.p+"assets/files/inference_api-adeec162709b5c758d2c3c143ed5cd8e.py"},4321:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>t,metadata:()=>a,toc:()=>l});var s=r(4848),i=r(8453);const t={title:"Inference"},o=void 0,a={id:"inference",title:"Inference",description:"This document presents how to use the KAITO workspace Custom Resource Definition (CRD) for model serving and serving with LoRA adapters.",source:"@site/docs/inference.md",sourceDirName:".",slug:"/inference",permalink:"/kaito/docs/inference",draft:!1,unlisted:!1,editUrl:"https://github.com/kaito-project/kaito/tree/main/website/docs/inference.md",tags:[],version:"current",frontMatter:{title:"Inference"},sidebar:"sidebar",previous:{title:"FAQ",permalink:"/kaito/docs/faq"},next:{title:"Fine Tuning",permalink:"/kaito/docs/tuning"}},c={},l=[{value:"Usage",id:"usage",level:2},{value:"Inference runtime selection",id:"inference-runtime-selection",level:3},{value:"Inference with custom parameters",id:"inference-with-custom-parameters",level:3},{value:"Inference with LoRA adapters",id:"inference-with-lora-adapters",level:3},{value:"Inference API",id:"inference-api",level:3},{value:"vLLM inference API",id:"vllm-inference-api",level:4},{value:"Transformers inference API",id:"transformers-inference-api",level:4},{value:"Workload update",id:"workload-update",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["This document presents how to use the KAITO ",(0,s.jsx)(n.code,{children:"workspace"})," Custom Resource Definition (CRD) for model serving and serving with LoRA adapters."]}),"\n",(0,s.jsx)(n.h2,{id:"usage",children:"Usage"}),"\n",(0,s.jsxs)(n.p,{children:["The basic usage for inference is simple. Users just need to specify the GPU SKU used for inference in the ",(0,s.jsx)(n.code,{children:"resource"})," spec and one of the KAITO supported model name in the ",(0,s.jsx)(n.code,{children:"inference"})," spec in the ",(0,s.jsx)(n.code,{children:"workspace"})," custom resource. For example,"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:'apiVersion: kaito.sh/v1beta1\nkind: Workspace\nmetadata:\n  name: workspace-falcon-7b\nresource:\n  instanceType: "Standard_NC24ads_A100_v4"\n  labelSelector:\n    matchLabels:\n      apps: falcon-7b\ninference:\n  preset:\n    name: "falcon-7b"\n'})}),"\n",(0,s.jsx)(n.p,{children:"If a user runs KAITO in an on-premise Kubernetes cluster where GPU SKUs are unavailable, the GPU nodes can be pre-configured. The user should ensure that the corresponding vendor-specific GPU plugin is installed successfully in every prepared node, i.e. the node status should report a non-zero GPU resource in the allocatable field. For example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'$ kubectl get node $NODE_NAME -o json | jq .status.allocatable\n{\n  "cpu": "XXXX",\n  "ephemeral-storage": "YYYY",\n  "hugepages-1Gi": "0",\n  "hugepages-2Mi": "0",\n  "memory": "ZZZZ",\n  "nvidia.com/gpu": "1",\n  "pods": "100"\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Next, the user needs to add the node names in the ",(0,s.jsx)(n.code,{children:"preferredNodes"})," field in the ",(0,s.jsx)(n.code,{children:"resource"})," spec. As a result, the KAITO controller will skip the steps for GPU node provisioning and use the prepared nodes to run the inference workload."]}),"\n",(0,s.jsx)(n.admonition,{type:"warning",children:(0,s.jsxs)(n.p,{children:["The node objects of the preferred nodes need to contain the same matching labels as specified in the ",(0,s.jsx)(n.code,{children:"resource"})," spec. Otherwise, the KAITO controller would not recognize them."]})}),"\n",(0,s.jsx)(n.h3,{id:"inference-runtime-selection",children:"Inference runtime selection"}),"\n",(0,s.jsxs)(n.p,{children:["KAITO now supports both ",(0,s.jsx)(n.a,{href:"https://github.com/vllm-project/vllm",children:"vLLM"})," and ",(0,s.jsx)(n.a,{href:"https://github.com/huggingface/transformers",children:"transformers"})," runtime. ",(0,s.jsx)(n.code,{children:"vLLM"})," provides better serving latency and throughput. ",(0,s.jsx)(n.code,{children:"transformers"})," provides more compatibility with models in the Huggingface model hub."]}),"\n",(0,s.jsxs)(n.p,{children:["From KAITO v0.4.0, the default runtime is switched to ",(0,s.jsx)(n.code,{children:"vLLM"}),". If you want to use ",(0,s.jsx)(n.code,{children:"transformers"})," runtime, you can specify the runtime in the ",(0,s.jsx)(n.code,{children:"inference"})," spec using an annotation. For example,"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:'apiVersion: kaito.sh/v1beta1\nkind: Workspace\nmetadata:\n  name: workspace-falcon-7b\n  annotations:\n    kaito.sh/runtime: "transformers"\nresource:\n  instanceType: "Standard_NC24ads_A100_v4"\n  labelSelector:\n    matchLabels:\n      apps: falcon-7b\ninference:\n  preset:\n    name: "falcon-7b"\n'})}),"\n",(0,s.jsx)(n.h3,{id:"inference-with-custom-parameters",children:"Inference with custom parameters"}),"\n",(0,s.jsxs)(n.p,{children:["Users can customize vLLM runtime parameters by creating a ConfigMap containing an ",(0,s.jsx)(n.code,{children:"inference_config.yaml"})," file and referencing it in the workspace spec. For example:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:'apiVersion: kaito.sh/v1beta1\nkind: Workspace\nmetadata:\n  namespace: myns\n  name: workspace-example\nresource:\n  instanceType: "Standard_NC24ads_A100_v4"\n  labelSelector:\n    matchLabels:\n      apps: example\ninference:\n  preset:\n    name: "example-model"\n  config: "my-inference-params"  # Reference to ConfigMap name\n---\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  namespace: myns\n  name: my-inference-params\ndata:\n  inference_config.yaml: |\n    max_probe_steps: 6\n    vllm:\n      gpu-memory-utilization: 0.95  # Controls GPU memory usage (0.0-1.0)\n      tensor-parallel-size: 2        # Number of GPUs for tensor parallelism\n      max-model-len: 131072         # Maximum sequence length\n      swap-space: 4                 # CPU swap space in GB\n      cpu-offload-gb: 0             # Amount of GPU memory to offload to CPU\n'})}),"\n",(0,s.jsx)(n.p,{children:"Key vLLM parameters include:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"gpu-memory-utilization"}),": Controls fraction of GPU memory allocated (between 0.0 and 1.0)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"tensor-parallel-size"}),": Number of GPUs to use for tensor parallelism"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"max-model-len"}),": Maximum sequence length the model can handle"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["For the complete list of vLLM parameters, refer to the ",(0,s.jsx)(n.a,{href:"https://docs.vllm.ai/en/latest/serving/engine_args.html",children:"vLLM documentation"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"inference-with-lora-adapters",children:"Inference with LoRA adapters"}),"\n",(0,s.jsxs)(n.p,{children:["KAITO also supports running the inference workload with LoRA adapters produced by ",(0,s.jsx)(n.a,{href:"/kaito/docs/tuning",children:"model fine-tuning jobs"}),". Users can specify one or more adapters in the ",(0,s.jsx)(n.code,{children:"adapters"})," field of the ",(0,s.jsx)(n.code,{children:"inference"})," spec. For example,"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:'apiVersion: kaito.sh/v1beta1\nkind: Workspace\nmetadata:\n  name: workspace-falcon-7b\nresource:\n  instanceType: "Standard_NC24ads_A100_v4"\n  labelSelector:\n    matchLabels:\n      apps: falcon-7b\ninference:\n  preset:\n    name: "falcon-7b"\n  adapters:\n    - source:\n        name: "falcon-7b-adapter"\n        image:  "<YOUR_IMAGE>"\n      strength: "0.2"\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Currently, only images are supported as adapter sources. The ",(0,s.jsx)(n.code,{children:"strength"})," field specifies the multiplier applied to the adapter weights relative to the raw model weights."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note:"})," When building a container image for an existing adapter, ensure all adapter files are copied to the ",(0,s.jsx)(n.strong,{children:"/data"})," directory inside the container."]}),"\n",(0,s.jsxs)(n.p,{children:["For detailed ",(0,s.jsx)(n.code,{children:"InferenceSpec"})," API definitions, refer to the ",(0,s.jsx)(n.a,{href:"https://github.com/kaito-project/kaito/blob/2ccc93daf9d5385649f3f219ff131ee7c9c47f3e/api/v1alpha1/workspace_types.go#L75",children:"documentation"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"inference-api",children:"Inference API"}),"\n",(0,s.jsxs)(n.p,{children:["The OpenAPI specification for the inference API is available at ",(0,s.jsx)(n.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:r(9090).A+"",children:"vLLM API"}),", ",(0,s.jsx)(n.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:r(6665).A+"",children:"transformers API"}),"."]}),"\n",(0,s.jsx)(n.h4,{id:"vllm-inference-api",children:"vLLM inference API"}),"\n",(0,s.jsxs)(n.p,{children:["vLLM supports OpenAI-compatible inference APIs. Check ",(0,s.jsx)(n.a,{href:"https://docs.vllm.ai/en/stable/serving/openai_compatible_server.html",children:"here"})," for more details."]}),"\n",(0,s.jsx)(n.h4,{id:"transformers-inference-api",children:"Transformers inference API"}),"\n",(0,s.jsxs)(n.p,{children:["The inference service endpoint is ",(0,s.jsx)(n.code,{children:"/chat"}),"."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"basic example"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'curl -X POST "http://<SERVICE>:80/chat" -H "accept: application/json" -H "Content-Type: application/json" -d \'{"prompt":"YOUR_PROMPT_HERE"}\'\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"example with full configurable parameters"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'curl -X POST \\\n    -H "accept: application/json" \\\n    -H "Content-Type: application/json" \\\n    -d \'{\n        "prompt":"YOUR_PROMPT_HERE",\n        "return_full_text": false,\n        "clean_up_tokenization_spaces": false,\n        "prefix": null,\n        "handle_long_generation": null,\n        "generate_kwargs": {\n                "max_length":200,\n                "min_length":0,\n                "do_sample":true,\n                "early_stopping":false,\n                "num_beams":1,\n                "num_beam_groups":1,\n                "diversity_penalty":0.0,\n                "temperature":1.0,\n                "top_k":10,\n                "top_p":1,\n                "typical_p":1,\n                "repetition_penalty":1,\n                "length_penalty":1,\n                "no_repeat_ngram_size":0,\n                "encoder_no_repeat_ngram_size":0,\n                "bad_words_ids":null,\n                "num_return_sequences":1,\n                "output_scores":false,\n                "return_dict_in_generate":false,\n                "forced_bos_token_id":null,\n                "forced_eos_token_id":null,\n                "remove_invalid_values":null\n            }\n        }\' \\\n        "http://<SERVICE>:80/chat"\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"parameters"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"prompt"}),": The initial text provided by the user, from which the model will continue generating text."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"return_full_text"}),": If False only generated text is returned, else full text is returned."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"clean_up_tokenization_spaces"}),": True/False, determines whether to remove potential extra spaces in the text output."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"prefix"}),": Prefix added to the prompt."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"handle_long_generation"}),": Provides strategies to address generations beyond the model's maximum length capacity."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"max_length"}),": The maximum total number of tokens in the generated text."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"min_length"}),": The minimum total number of tokens that should be generated."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"do_sample"}),": If True, sampling methods will be used for text generation, which can introduce randomness and variation."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"early_stopping"}),": If True, the generation will stop early if certain conditions are met, for example, when a satisfactory number of candidates have been found in beam search."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"num_beams"}),": The number of beams to be used in beam search. More beams can lead to better results but are more computationally expensive."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"num_beam_groups"}),": Divides the number of beams into groups to promote diversity in the generated results."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"diversity_penalty"}),": Penalizes the score of tokens that make the current generation too similar to other groups, encouraging diverse outputs."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"temperature"}),": Controls the randomness of the output by scaling the logits before sampling."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"top_k"}),": Restricts sampling to the k most likely next tokens."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"top_p"}),": Uses nucleus sampling to restrict the sampling pool to tokens comprising the top p probability mass."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"typical_p"}),': Adjusts the probability distribution to favor tokens that are "typically" likely, given the context.']}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"repetition_penalty"}),": Penalizes tokens that have been generated previously, aiming to reduce repetition."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"length_penalty"}),": Modifies scores based on sequence length to encourage shorter or longer outputs."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"no_repeat_ngram_size"}),": Prevents the generation of any n-gram more than once."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"encoder_no_repeat_ngram_size"}),": Similar to ",(0,s.jsx)(n.code,{children:"no_repeat_ngram_size"})," but applies to the encoder part of encoder-decoder models."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"bad_words_ids"}),": A list of token ids that should not be generated."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"num_return_sequences"}),": The number of different sequences to generate."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"output_scores"}),": Whether to output the prediction scores."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"return_dict_in_generate"}),": If True, the method will return a dictionary containing additional information."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"pad_token_id"}),": The token ID used for padding sequences to the same length."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"eos_token_id"}),": The token ID that signifies the end of a sequence."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"forced_bos_token_id"}),": The token ID that is forcibly used as the beginning of a sequence token."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"forced_eos_token_id"}),": The token ID that is forcibly used as the end of a sequence when max_length is reached."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"remove_invalid_values"}),": If True, filters out invalid values like NaNs or infs from model outputs to prevent crashes."]}),"\n"]}),"\n",(0,s.jsx)(n.h1,{id:"inference-workload",children:"Inference workload"}),"\n",(0,s.jsxs)(n.p,{children:["Depending on whether the specified model supports distributed inference or not, the KAITO controller will choose to use either Kubernetes ",(0,s.jsx)(n.strong,{children:"apps.deployment"})," workload (by default) or Kubernetes ",(0,s.jsx)(n.strong,{children:"apps.statefulset"})," workload (if the model supports distributed inference) to manage the inference service, which is exposed using a Cluster-IP type of Kubernetes ",(0,s.jsx)(n.code,{children:"service"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["When adapters are specified in the ",(0,s.jsx)(n.code,{children:"inference"})," spec, the KAITO controller adds an initcontainer for each adapter in addition to the main container. The pod structure is shown in Figure 1."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"KAITO inference service pod structure",src:r(9293).A+"",width:"1133",height:"1339"})}),"\n",(0,s.jsxs)(n.p,{children:["If an image is specified as the adapter source, the corresponding initcontainer uses that image as its container image. These initcontainers ensure all adapter data is available locally before the inference service starts. The main container uses a supported model image, launching the ",(0,s.jsx)(n.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:r(3614).A+"",children:"inference_api.py"})," script."]}),"\n",(0,s.jsxs)(n.p,{children:["All containers share local volumes by mounting the same ",(0,s.jsx)(n.code,{children:"EmptyDir"})," volumes, avoiding file copies between containers."]}),"\n",(0,s.jsx)(n.h2,{id:"workload-update",children:"Workload update"}),"\n",(0,s.jsxs)(n.p,{children:["To update the ",(0,s.jsx)(n.code,{children:"adapters"})," field in the ",(0,s.jsx)(n.code,{children:"inference"})," spec, users can modify the ",(0,s.jsx)(n.code,{children:"workspace"})," custom resource. The KAITO controller will apply the changes, triggering a workload deployment update. This will recreate the inference service pod, resulting in a brief service downtime. Once the new adapters are merged with the raw model weights and loaded into GPU memory, the service will resume."]}),"\n",(0,s.jsx)(n.h1,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,s.jsx)(n.p,{children:"TBD"})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},6665:(e,n,r)=>{r.d(n,{A:()=>s});const s=r.p+"assets/files/api_spec-d60bfdda4b02eeb38b44b00803e2eb8d.json"},8453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>a});var s=r(6540);const i={},t=s.createContext(i);function o(e){const n=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(t.Provider,{value:n},e.children)}},9090:(e,n,r)=>{r.d(n,{A:()=>s});const s=r.p+"assets/files/api_spec-98cf405e6c5d2e08cecc108586cf2ec3.json"},9293:(e,n,r)=>{r.d(n,{A:()=>s});const s=r.p+"assets/images/kaito-inference-adapter-7c210dbce8b362f0eb10f58507034958.png"}}]);